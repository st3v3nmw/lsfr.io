<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Crash Recovery# Your server currently saves data on clean shutdown but loses everything if it crashes. In this stage, you’ll add durability so data survives unexpected failures.
Write-Ahead Logging# Implement a Write-Ahead Log (WAL) that records operations before they’re applied to memory. Each write operation must be written to the log file before updating your in-memory store.
Log Format# Your log should record operations in append-only fashion. The format is up to you - JSONL (one JSON object per line), binary serialization, or plain text all work.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lsfr.io/kv-store/crash-recovery/"><meta property="og:site_name" content="lsfr.io"><meta property="og:title" content="Crash Recovery"><meta property="og:description" content="Crash Recovery# Your server currently saves data on clean shutdown but loses everything if it crashes. In this stage, you’ll add durability so data survives unexpected failures.
Write-Ahead Logging# Implement a Write-Ahead Log (WAL) that records operations before they’re applied to memory. Each write operation must be written to the log file before updating your in-memory store.
Log Format# Your log should record operations in append-only fashion. The format is up to you - JSONL (one JSON object per line), binary serialization, or plain text all work."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="kv-store"><meta property="article:modified_time" content="2025-12-27T11:34:22+03:00"><meta itemprop=name content="Crash Recovery"><meta itemprop=description content="Crash Recovery# Your server currently saves data on clean shutdown but loses everything if it crashes. In this stage, you’ll add durability so data survives unexpected failures.
Write-Ahead Logging# Implement a Write-Ahead Log (WAL) that records operations before they’re applied to memory. Each write operation must be written to the log file before updating your in-memory store.
Log Format# Your log should record operations in append-only fashion. The format is up to you - JSONL (one JSON object per line), binary serialization, or plain text all work."><meta itemprop=dateModified content="2025-12-27T11:34:22+03:00"><meta itemprop=wordCount content="642"><title>Crash Recovery | lsfr.io</title><link rel=icon href=/fa-feather.svg><link rel=manifest href=/manifest.json><link rel=canonical href=https://lsfr.io/kv-store/crash-recovery/><link rel=stylesheet href=/book.min.ab49e21559bbdf668d64e765afb333baceaf7efe3f272a8318e6d68e610a0d3f.css integrity="sha256-q0niFVm732aNZOdlr7Mzus6vfv4/JyqDGObWjmEKDT8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.f5a1d1313e4ad0bef71a60a2cb77314bc76716b6c1d10fc3a545841f73fd58c3.js integrity="sha256-9aHRMT5K0L73GmCiy3cxS8dnFrbB0Q/DpUWEH3P9WMM=" crossorigin=anonymous></script><script src=https://giscus.app/client.js data-repo=st3v3nmw/lsfr.io data-repo-id=R_kgDOPGeL5g data-category=Giscus data-category-id=DIC_kwDOPGeL5s4Cs3JN data-mapping=pathname data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></head><body dir=ltr class="book-kind-page book-type-kv-store"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/fa-feather.svg alt=Logo class=book-icon><i>lsfr.io</i></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/how-lsfr-works/>How lsfr Works</a></li><li><input type=checkbox id=section-9c02cfb52851d47ab5511a2e6400e2c6 class=toggle checked>
<label for=section-9c02cfb52851d47ab5511a2e6400e2c6 class=flex><a href=/kv-store/>Distributed Key-Value Store</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/kv-store/http-api/>HTTP API</a></li><li><a href=/kv-store/persistence/>Persistence</a></li><li><a href=/kv-store/crash-recovery/ class=active>Crash Recovery</a></li><li><a href=/kv-store/clustering/>Clustering</a></li><li><a href=/kv-store/read-replicas/>Read Replicas</a></li><li><a href=/kv-store/fault-tolerance/>Fault Tolerance</a></li><li><a href=/kv-store/strong-consistency/>Strong Consistency</a></li><li><a href=/kv-store/sharding/>Sharding</a></li></ul></li><li><a>Guides</a><ul><li><a href=/guides/cli/>CLI</a></li><li><a href=/guides/ci-cd/>CI/CD</a></li></ul></li><li><input type=checkbox id=section-f726ddd70f9df03e77714ffcd941e3f8 class=toggle>
<label for=section-f726ddd70f9df03e77714ffcd941e3f8 class=flex><a role=button>Reference</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/reference/testing/>Testing</a></li><li><a href=/reference/writing-style/>Writing Style</a></li></ul></li><li><a href=/about/>About</a></li></ul><ul><li><a href=https://github.com/st3v3nmw/lsfr target=_blank rel=noopener>GitHub</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3><i><a href=/ style=color:inherit;text-decoration:none>lsfr.io</a></i></h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#write-ahead-logging>Write-Ahead Logging</a><ul><li><a href=#log-format>Log Format</a></li><li><a href=#durability>Durability</a></li></ul></li><li><a href=#recovery-procedure>Recovery Procedure</a><ul><li><a href=#handling-corrupted-logs>Handling Corrupted Logs</a></li></ul></li><li><a href=#checkpointing>Checkpointing</a></li><li><a href=#storage-layout>Storage Layout</a></li><li><a href=#testing>Testing</a><ul><li><a href=#debugging>Debugging</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=crash-recovery>Crash Recovery<a class=anchor href=#crash-recovery>#</a></h1><p>Your server currently saves data on clean shutdown but loses everything if it crashes. In this stage, you&rsquo;ll add durability so data survives unexpected failures.</p><h2 id=write-ahead-logging>Write-Ahead Logging<a class=anchor href=#write-ahead-logging>#</a></h2><p>Implement a <a href=https://www.architecture-weekly.com/p/the-write-ahead-log-a-foundation>Write-Ahead Log (WAL)</a> that records operations before they&rsquo;re applied to memory. Each write operation must be written to the log file before updating your in-memory store.</p><h3 id=log-format>Log Format<a class=anchor href=#log-format>#</a></h3><p>Your log should record operations in append-only fashion. The format is up to you - <a href=https://jsonlines.org/>JSONL</a> (one JSON object per line), binary serialization, or plain text all work.</p><p>Each log entry needs enough information to replay the operation:</p><ul><li>Operation type (e.g., &ldquo;set&rdquo;, &ldquo;delete&rdquo;, &ldquo;clear&rdquo;)</li><li>Key</li><li>Value</li><li>Any other metadata you need for replay</li></ul><h3 id=durability>Durability<a class=anchor href=#durability>#</a></h3><p>After appending an operation to the log, ensure it&rsquo;s physically written to disk before responding to the client. Use your language&rsquo;s file sync mechanism (<code>fsync</code>, <code>flush</code>, etc.) to force the operating system to persist the write.</p><p>Without sync, the OS may buffer writes in memory and you&rsquo;ll lose data on crash.</p><blockquote class='book-hint warning'><p>Syncing on every operation is slow since you&rsquo;re forcing a disk write and blocking the response. This is the correct trade-off for durability, but it limits throughput. Production databases use techniques like batching to amortize the fsync cost across multiple operations.</p></blockquote><h2 id=recovery-procedure>Recovery Procedure<a class=anchor href=#recovery-procedure>#</a></h2><p>When your server starts:</p><ol><li>Load the most recent snapshot (from the persistence stage) if one exists</li><li>Replay all operations from the WAL that occurred after the snapshot</li><li>Resume serving requests</li></ol><p>If no snapshot exists, replay the entire log from the beginning.</p><h3 id=handling-corrupted-logs>Handling Corrupted Logs<a class=anchor href=#handling-corrupted-logs>#</a></h3><p>The log file may contain partial writes at the end if the server crashed mid-write. Your replay logic should handle this gracefully:</p><ul><li>Skip incomplete/corrupted entries at the end of the log</li><li>Process all valid entries before the corruption</li><li>Continue serving requests with the recovered data</li></ul><h2 id=checkpointing>Checkpointing<a class=anchor href=#checkpointing>#</a></h2><p>As your log grows, replaying from the beginning becomes slow. Periodically create snapshots of your in-memory state and truncate the log.</p><p>When to checkpoint is up to you - after N operations, every M seconds, when the log reaches a certain size, etc. The test doesn&rsquo;t care about your checkpoint strategy, only that recovery works correctly.</p><p>After creating a snapshot:</p><ol><li>Write the snapshot to a new file</li><li>Truncate or create a new WAL file</li><li>Continue logging operations</li></ol><p>On recovery, load the latest snapshot and replay only the operations logged after that snapshot.</p><blockquote class='book-hint warning'><p>Don&rsquo;t delete the old snapshot until the new one is safely on disk. If you crash during checkpointing, you need the old snapshot and log to be intact.</p></blockquote><h2 id=storage-layout>Storage Layout<a class=anchor href=#storage-layout>#</a></h2><p>You now have two types of files:</p><ul><li><strong>Snapshot</strong>: Full state at a point in time (from previous stage)</li><li><strong>WAL</strong>: Operations logged since the last snapshot</li></ul><p>Organize these in the working directory however makes sense - separate files, subdirectories, naming conventions, etc. The test only cares that recovery works, not how you structure the files.</p><h2 id=testing>Testing<a class=anchor href=#testing>#</a></h2><p>Your server will be started with the working directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ ./run.sh --port <span style=color:#ae81ff>8080</span> --working-dir .lsfr/run-20251226-210357
</span></span></code></pre></div><p>Your server will be tested with unexpected crashes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ lsfr test crash-recovery
</span></span><span style=display:flex><span>Testing crash-recovery: Write-Ahead Logging and Recovery
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>✓ Basic WAL Durability
</span></span><span style=display:flex><span>✓ Recovery After Crash
</span></span><span style=display:flex><span>✓ Multiple Crash Recovery Cycles
</span></span><span style=display:flex><span>✓ Checkpoint and Replay
</span></span><span style=display:flex><span>✓ Corrupted Log Handling
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>PASSED ✓
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>Run &#39;lsfr next&#39; to advance to the next stage.
</span></span></code></pre></div><p>The test will:</p><ol><li>Send PUT/DELETE/CLEAR operations to your server</li><li>Kill the server process (SIGKILL) without warning</li><li>Restart your server</li><li>Verify all data that was acknowledged before the crash is still present</li></ol><h3 id=debugging>Debugging<a class=anchor href=#debugging>#</a></h3><p>When tests fail, <code>lsfr</code> shows what data was lost:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ lsfr test crash-recovery
</span></span><span style=display:flex><span>Testing crash-recovery: Write-Ahead Logging and Recovery
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>✓ Basic WAL Durability
</span></span><span style=display:flex><span>✗ Recovery After Crash
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>Before crash: PUT /kv/user_123 → &#34;alice&#34;
</span></span><span style=display:flex><span>After crash: GET /kv/user_123 → 404 Not Found
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>Your server acknowledged the PUT but lost the data after crashing.
</span></span><span style=display:flex><span>Make sure you&#39;re syncing the WAL to disk (fsync) before responding to writes.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>FAILED ✗
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>Read the guide: lsfr.io/kv-store/crash-recovery
</span></span></code></pre></div></article><div class=giscus></div><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/kv-store/persistence/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>Persistence</span>
</a></span><span><a href=/kv-store/clustering/ class="flex align-center"><span>Clustering</span>
<img src=/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class="book-copyright flex justify-center"><small>lsfr.io - <a href=https://github.com/st3v3nmw/lsfr.io/blob/main/LICENSE>© CC BY 4.0</a></small></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#write-ahead-logging>Write-Ahead Logging</a><ul><li><a href=#log-format>Log Format</a></li><li><a href=#durability>Durability</a></li></ul></li><li><a href=#recovery-procedure>Recovery Procedure</a><ul><li><a href=#handling-corrupted-logs>Handling Corrupted Logs</a></li></ul></li><li><a href=#checkpointing>Checkpointing</a></li><li><a href=#storage-layout>Storage Layout</a></li><li><a href=#testing>Testing</a><ul><li><a href=#debugging>Debugging</a></li></ul></li></ul></nav></div></aside></main></body></html>