[{"id":0,"href":"/how-lsfr-works/","title":"How lsfr Works","section":"","content":" How lsfr Works # Reading about how systems work is one thing. Building them is another.\nlsfr breaks down complex systems into stages you can actually implement. Build a distributed database, write a compiler, or create a message queue from scratch. Each challenge starts simple and adds complexity one stage at a time.\nYou write real code that actually works. Tests verify your implementation handles the hard problems: network failures, crash recovery, concurrent access, etc. By the end, you understand these systems because you\u0026rsquo;ve built them yourself.\nChallenges # Each challenge breaks down a complex system into manageable stages that can be built incrementally. For instance, the distributed key-value store challenge starts with a simple in-memory store with a HTTP API and by the end, you have a sharded distributed key-value store.\nEach stage comes with tests that simulate real-world scenarios like network failures and crash recovery. The tests verify your system\u0026rsquo;s behavior, not implementation details, so you\u0026rsquo;re free to choose your own data structures, algorithms, and approaches. These are essentially end-to-end tests that check if your system actually works.\nEach stage explains what you need to implement and links out to good resources for learning more. Why reinvent the wheel when Kleppmann and others have already explained it better? üòÖ\nReady to try it out? Here\u0026rsquo;s how to set up lsfr and start your first challenge.\nInstallation # See this guide on how to install lsfr on your system.\nPick a Challenge # Start with the distributed key-value store challenge; it\u0026rsquo;s a great introduction to distributed systems concepts. Check the challenge\u0026rsquo;s page for details on the first stage.\nGet the Scaffold # Run lsfr new kv-store to create a new challenge directory with:\nrun.sh - Builds and runs your implementation README.md - Challenge overview and requirements lsfr.yaml - Tracks your progress Update run.sh with the commands to build and run your implementation. You can use any language - Go, Python, Rust, even Ponylang - as long as run.sh can start your program and pass through any command-line arguments from lsfr test.\nImplement and Test # Write your implementation in any language to solve the challenge\u0026rsquo;s first stage. When ready, run lsfr test to verify your solution works correctly. The tests focus on behavior, not implementation details.\nAdvance Through Stages # Pass the current stage, then run lsfr next to unlock the next stage. Each stage builds on the previous one, gradually adding complexity.\nBy the end of the challenge, you\u0026rsquo;ll have a deep understanding of how these systems actually work because you built one yourself.\nGood luck! üöÄ\n"},{"id":1,"href":"/kv-store/http-api/","title":"HTTP API","section":"Distributed Key-Value Store","content":" HTTP API # // TODO\n"},{"id":2,"href":"/guides/cli/","title":"CLI","section":"Guides","content":" CLI # // TODO\nInstallation # "},{"id":3,"href":"/kv-store/","title":"Distributed Key-Value Store","section":"","content":" Distributed Key-Value Store Challenge # Welcome to the distributed key-value store challenge!\nIn this challenge, you\u0026rsquo;ll build a distributed key-value store from scratch. You\u0026rsquo;ll start with a simple HTTP API and progressively add persistence, crash recovery, clustering, replication, and consensus mechanisms.\nBy the end, you\u0026rsquo;ll have built a system that can handle node failures, network partitions, and scale across multiple nodes while maintaining data consistency.\nStages # HTTP API Build a basic in-memory key-value store with GET/PUT/DELETE operations over HTTP.\nPersistence Add durability to your store. Data should survive clean shutdowns (SIGTERM).\nCrash Recovery Handle unclean shutdowns (SIGKILL). Ensure data consistency after crashes.\nClustering Discover and connect to other nodes in a leader-follower arrangement.\nRead Replicas Add read replicas that follow the leader. Handle eventual consistency across the cluster.\nFault Tolerance Handle leader failures and network partitions while maintaining cluster consistency.\nStrong Consistency Implement strong consistency guarantees for read and write operations.\nSharding Distribute data across multiple shards for horizontal scaling.\nGetting Started # If you haven\u0026rsquo;t already, read this overview on how lsfr works and then start with stage 1 (HTTP API).\nResources # Books # Designing Data-Intensive Applications by Martin Kleppmann Database Internals by Alex Petrov Videos # Distributed Systems lecture series by Martin Kleppmann Intro to Database Systems by CMU Database Group "},{"id":4,"href":"/kv-store/persistence/","title":"Persistence","section":"Distributed Key-Value Store","content":" Persistence # // TODO\n"},{"id":5,"href":"/guides/contributing/","title":"Contributing","section":"Guides","content":" Contributing # // TODO\n"},{"id":6,"href":"/kv-store/crash-recovery/","title":"Crash Recovery","section":"Distributed Key-Value Store","content":" Crash Recovery # // TODO\n"},{"id":7,"href":"/kv-store/clustering/","title":"Clustering","section":"Distributed Key-Value Store","content":" Clustering # // TODO\n"},{"id":8,"href":"/kv-store/read-replicas/","title":"Read Replicas","section":"Distributed Key-Value Store","content":" Read Replicas # // TODO\n"},{"id":9,"href":"/kv-store/fault-tolerance/","title":"Fault Tolerance","section":"Distributed Key-Value Store","content":" Fault Tolerance # // TODO\n"},{"id":10,"href":"/kv-store/strong-consistency/","title":"Strong Consistency","section":"Distributed Key-Value Store","content":" Strong Consistency # // TODO\n"},{"id":11,"href":"/kv-store/sharding/","title":"Sharding","section":"Distributed Key-Value Store","content":" Sharding # // TODO\n"},{"id":12,"href":"/about/","title":"About","section":"","content":" About # lsfr /Àà…õl Àà…õs Àà…õf Àà…ër/ noun\nNamed after the song \u0026ldquo;Love Songs For Robots\u0026rdquo; by Patrick Watson.\nI have always been interested in distributed systems so when I finally got around to reading Designing Data-Intensive Applications, I thought \u0026ldquo;you know what, I should actually build some of this stuff to really understand it\u0026rdquo;. And that\u0026rsquo;s how lsfr was born: it breaks down complex systems into stages you can implement and test.\nI hope this helps someone out there actually build these systems and learn how they work. I\u0026rsquo;ll be adding more challenges over time üòÖ.\nBuilt with ‚ù§Ô∏è by Stephen Mwangi | Content: CC BY 4.0\n"}]