[{"id":0,"href":"/how-lsfr-works/","title":"How lsfr Works","section":"Home","content":" How lsfr Works # Reading about how systems work is one thing. Building them is another.\nlsfr breaks down complex systems into stages you can actually implement. Build a distributed database, write a compiler, or create a message queue from scratch. Each challenge starts simple and adds complexity one stage at a time.\nYou write real code that actually works. Tests verify your implementation handles the hard problems: network failures, crash recovery, concurrent access, etc. By the end, you understand these systems because you\u0026rsquo;ve built them yourself.\nChallenges # Each challenge breaks down a complex system into manageable stages that can be built incrementally. For instance, the distributed key-value store challenge starts with a simple in-memory store with a HTTP API and by the end, you have a sharded distributed key-value store.\nEach stage comes with tests that simulate real-world scenarios like network failures and crash recovery. The tests verify your system\u0026rsquo;s behavior, not implementation details, so you\u0026rsquo;re free to choose your own data structures, algorithms, and approaches. These are essentially end-to-end tests that check if your system actually works.\nEach stage explains what you need to implement and links out to good resources for learning more. Why reinvent the wheel when Kleppmann and others have already explained it better? 😅\nReady to try it out? Here\u0026rsquo;s how to set up lsfr and start your first challenge.\nInstallation # See this guide on how to install lsfr on your system.\nPick a Challenge # Start with the distributed key-value store challenge; it\u0026rsquo;s a great introduction to distributed systems concepts. Check the challenge\u0026rsquo;s page for details on the first stage.\nScaffolding # Run lsfr new kv-store to create a new challenge directory with:\nrun.sh - Builds and runs your implementation README.md - Challenge overview and requirements lsfr.yaml - Tracks your progress Update run.sh with the commands to build and run your implementation. You can use any language - Go, Python, Rust, even Ponylang - as long as run.sh can start your program and pass through any command-line arguments from lsfr test.\nImplement \u0026amp; Test # Write your implementation in any language to solve the challenge\u0026rsquo;s first stage. When ready, run lsfr test to verify your solution works correctly. The tests focus on behavior, not implementation details.\nAdvance Through Stages # Pass the current stage, then run lsfr next to unlock the next stage. Each stage builds on the previous one, gradually adding complexity.\nBy the end of the challenge, you\u0026rsquo;ll have a deep understanding of how these systems actually work because you built one yourself.\nGood luck! 🚀\n"},{"id":1,"href":"/kv-store/http-api/","title":"HTTP API","section":"Distributed Key-Value Store","content":" HTTP API # In this stage, you\u0026rsquo;ll build an in-memory key-value store and expose it over a REST API.\nEndpoints # You\u0026rsquo;ll implement the following endpoints:\nPUT /kv/{key} Add or update a key-value pair in the store.\nPUT /kv/{key} Parameters: - key (path, required): The key to store (cannot be empty) Body: Value to store as plain text (cannot be empty) Response: - 200 OK: Key-value pair added or updated successfully - 400 Bad Request: Return \u0026#34;key cannot be empty\\n\u0026#34; or \u0026#34;value cannot be empty\\n\u0026#34; GET /kv/{key} Retrieve the value associated with the given key.\nGET /kv/{key} Parameters: - key (path, required): The key to retrieve Response: - 200 OK: Return the stored value - 404 Not Found: Return \u0026#34;key not found\\n\u0026#34; DELETE /kv/{key} Remove a key-value pair from the store.\nDELETE /kv/{key} Parameters: - key (path, required): The key to delete Response: - 200 OK: Key deleted successfully (or key didn\u0026#39;t exist) DELETE /clear Remove all key-value pairs from the store.\nDELETE /clear Response: - 200 OK: All keys cleared successfully Error Handling Unsupported HTTP methods on any endpoint should return:\n405 Method Not Allowed: Return \u0026ldquo;method not allowed\\n\u0026rdquo; Your API should handle concurrent requests safely. Consider thread safety when implementing your in-memory store.\nStorage # A simple in-memory map/dictionary is sufficient for storage in this stage. You\u0026rsquo;ll add persistence in the next stage.\nData Model # Keys and values are stored as simple strings. This keeps the data model straightforward so you can focus on building intuition in distributed systems, not implementing complex data types.\nKeys # Keys must be URL-safe strings without spaces or forward slashes. Examples of valid keys:\ncountry:capital user_123 special:key-with_symbols.123 Values # Values are stored as UTF-8 encoded text and can contain:\nUnicode characters like 😊 Spaces and special symbols Long strings (up to reasonable memory limits) Testing # You can test your implementation using the lsfr command. Your program should accept a --port flag that lsfr will use to tell it what port to run on.\n$ lsfr test http-api Running http-api: HTTP API with GET/PUT/DELETE Operations ✓ PUT Basic Operations ✓ PUT Edge and Error Cases ✓ GET Basic Operations ✓ GET Edge and Error Cases ✓ DELETE Basic Operations ✓ DELETE Edge and Error Cases ✓ Concurrent Operations ✓ Check Allowed HTTP Methods PASSED ✓ Run \u0026#39;lsfr next\u0026#39; to advance to the next stage. Debugging # When tests fail, lsfr will show you exactly what went wrong:\n$ lsfr test Running http-api: HTTP API with GET/PUT/DELETE Operations ✓ PUT Basic Operations ✓ PUT Edge and Error Cases ✓ GET Basic Operations ✗ GET Edge and Error Cases GET http://127.0.0.1:42409/kv/nonexistent:key Expected response: \u0026#34;key not found\\n\u0026#34; Actual response: \u0026#34;\\n\u0026#34; Your server should return 404 Not Found when a key doesn\u0026#39;t exist. Check your key lookup logic and error handling. FAILED ✗ Read the guide: lsfr.io/kv-store/http-api "},{"id":2,"href":"/reference/testing/","title":"Testing","section":"Reference","content":" Testing # // TODO\n"},{"id":3,"href":"/guides/cli/","title":"CLI","section":"Guides","content":" CLI # // TODO\nInstallation # "},{"id":4,"href":"/kv-store/","title":"Distributed Key-Value Store","section":"Home","content":" Distributed Key-Value Store Challenge # Welcome to the distributed key-value store challenge!\nIn this challenge, you\u0026rsquo;ll build a distributed key-value store from scratch. You\u0026rsquo;ll start with a simple HTTP API and progressively add persistence, crash recovery, clustering, replication, and consensus mechanisms.\nBy the end, you\u0026rsquo;ll have built a system that can handle node failures, network partitions, and scale across multiple nodes while maintaining data consistency.\nStages # HTTP API Build a basic in-memory key-value store with GET/PUT/DELETE operations over HTTP.\nPersistence Add durability to your store. Data should survive clean shutdowns (SIGTERM).\nCrash Recovery Ensure data consistency after crashes. Data should survive unclean shutdowns (SIGKILL).\nClustering Discover and connect to other nodes in a leader-follower arrangement.\nRead Replicas Add read replicas that follow the leader. Handle eventual consistency across the cluster.\nFault Tolerance Handle leader failures and network partitions while maintaining cluster consistency.\nStrong Consistency Implement strong consistency guarantees for read and write operations.\nSharding Distribute data across multiple shards for horizontal scaling.\nGetting Started # If you haven\u0026rsquo;t already, read this overview on how lsfr works and then start with stage 1 (HTTP API).\nResources # Books # Designing Data-Intensive Applications by Martin Kleppmann Database Internals by Alex Petrov Videos # Distributed Systems lecture series by Martin Kleppmann Implementations # little-key-value in Go by @st3v3nmw "},{"id":5,"href":"/kv-store/persistence/","title":"Persistence","section":"Distributed Key-Value Store","content":" Persistence # In this stage, you\u0026rsquo;ll add persistence to your key-value store. Data should survive clean shutdowns and be restored when the server restarts.\nClean Shutdown # When your server receives a SIGTERM signal, it should:\nSave all key-value pairs to disk Exit gracefully Startup Recovery # When your server starts, it should:\nCheck the data directory for existing data Load any previously saved key-value pairs Continue serving requests with the restored data If no previous data exists, start with an empty store.\nStorage # You can store the data however you choose; the implementation is up to you. Some approaches to consider:\nStorage Strategy:\nSnapshot on shutdown: Save all data after receiving SIGTERM Continuous persistence: Save changes as they happen Data Structures:\nSimple formats: JSON \u0026amp; binary serialization, plain text files, etc Tree-based: B-trees, Log-structured merge-trees (LSM trees), etc Your server must accept a --data-dir flag that specifies where to persist data:\n$ ./run.sh --port 8080 --data-dir /tmp/tmpzz5vkl5d "},{"id":6,"href":"/guides/contributing/","title":"Contributing","section":"Guides","content":" Contributing # // TODO\n"},{"id":7,"href":"/kv-store/crash-recovery/","title":"Crash Recovery","section":"Distributed Key-Value Store","content":" Crash Recovery # // TODO\n"},{"id":8,"href":"/kv-store/clustering/","title":"Clustering","section":"Distributed Key-Value Store","content":" Clustering # // TODO\n"},{"id":9,"href":"/kv-store/read-replicas/","title":"Read Replicas","section":"Distributed Key-Value Store","content":" Read Replicas # // TODO\n"},{"id":10,"href":"/kv-store/fault-tolerance/","title":"Fault Tolerance","section":"Distributed Key-Value Store","content":" Fault Tolerance # // TODO\n"},{"id":11,"href":"/kv-store/strong-consistency/","title":"Strong Consistency","section":"Distributed Key-Value Store","content":" Strong Consistency # // TODO\n"},{"id":12,"href":"/kv-store/sharding/","title":"Sharding","section":"Distributed Key-Value Store","content":" Sharding # // TODO\n"},{"id":13,"href":"/about/","title":"About","section":"Home","content":" About # lsfr /ˈɛl ˈɛs ˈɛf ˈɑr/ noun\nNamed after the song \u0026ldquo;Love Songs For Robots\u0026rdquo; by Patrick Watson.\nI have always been interested in distributed systems so when I finally got around to reading Designing Data-Intensive Applications, I thought \u0026ldquo;you know what, I should actually build some of this stuff to really understand it\u0026rdquo;. And that\u0026rsquo;s how lsfr was born: it breaks down complex systems into stages you can implement and test.\nBuilt with ❤️ by Stephen Mwangi | Content: CC BY 4.0\n"}]